# 创建对象

## 野路子
```javascript
const factory = (age, gender) => {
    return {
        age: age,
        gender: gender
    }
}
console.log(factory(10, 'male'));
// age: 10
// gender: "male"
// __proto__:
//     constructor: ƒ Object()
//     hasOwnProperty: ƒ hasOwnProperty()
//     isPrototypeOf: ƒ isPrototypeOf()
//     propertyIsEnumerable: ƒ propertyIsEnumerable()
//     toLocaleString: ƒ toLocaleString()
//     toString: ƒ toString()
//     valueOf: ƒ valueOf()
//     __defineGetter__: ƒ __defineGetter__()
//     __defineSetter__: ƒ __defineSetter__()
//     __lookupGetter__: ƒ __lookupGetter__()
//     __lookupSetter__: ƒ __lookupSetter__()
//     get __proto__: ƒ __proto__()
//     set __proto__: ƒ __proto__()
```

## NEW
```javascript
function Person(firstName) {
  this.firstName = firstName;
}

Person.prototype.sayHello = function() {
  alert("Hello, I'm " + this.firstName);
};

var person1 = new Person("Alice");
var person2 = new Person("Bob");

// call the Person sayHello method.
person1.sayHello(); // alerts "Hello, I'm Alice"
person2.sayHello(); // alerts "Hello, I'm Bob"

console.log(person1);
Person {firstName: "Alice"}
```

Person {firstName: "Alice"}

- firstName: "Alice"
- `__proto__`:
    - sayHello: ƒ ()
    - constructor: ƒ Person(firstName)
    - `__proto__`: Object

# 继承
https://zhuanlan.zhihu.com/p/37735247

## 原型链继承
父类的实例作为子类的原型。
```javascript
function People(age) {
    this.age = age || 50;
}

function Woman(){ 

}
Woman.prototype= new People();
Woman.prototype.name = 'haixia';
let womanObj = new Woman();
console.log(womanObj);
```
- 优点
    1. 父类新增的属性name，子类能访问
- 缺点
    1. 无法实现多继承
    2. 创建子类实例时，不能向父类构造函数中传参
    3. 啥意思？如果要新增加原型属性和方法需要在new 父类构造函数的后面

## 借用构造函数继承（伪造对象、经典继承）
复制父类的实例属性给子类。
```javascript
function Woman(name){
 //继承了People
  People.call(this); //People.call(this，'wangxiaoxia'); 
  this.name = name || 'renbo'
}
let womanObj = new Woman();
console.log(womanObj);
```

- 优点
    1. 这样就可以多继承了

Woman {age: 50, name: "renbo"}
- age: 50
- name: "renbo"
- `__proto__`: Object

```
function People(name,age){
  this.name = name || 'wangxiao'
  this.age = age || 27
}
People.prototype.eat = function(){
  return this.name + this.age + 'eat sleep'
}

function Woman(name,age){
  People.call(this,name,age)
}
Woman.prototype = new People();
Woman.prototype.constructor = Woman;
let wonmanObj = new Woman(ren,27);
wonmanObj.eat(); 
```

```
//父类
function People(name,age){
  this.name = name || 'wangxiao'
  this.age = age || 27
}
//父类方法
People.prototype.eat = function(){
  return this.name + this.age + 'eat sleep'
}
//子类
function Woman(name,age){
  //继承父类属性
  People.call(this,name,age)
}
//继承父类方法
(function(){
  // 创建空类
  let Super = function(){};
  Super.prototype = People.prototype;
  //父类的实例作为子类的原型
  Woman.prototype = new Super();
})();
//修复构造函数指向问题
Woman.prototype.constructor = Woman;
let womanObj = new Woman();

```
