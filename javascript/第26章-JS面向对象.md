# 创建对象


## 基于已经创建出来的实例，进行创建
```javascript
function Person(first, last, age, gender, interests) {
  // 属性与方法定义
  this.first = first;
  this.last = last;
  this.age = age;
  this.gender = gender;
  this.interests = interests;
};
let person1 = new Person('Bob', 'Smith', 32, 'male', ['music', 'skiing']);
```
原型链: person1 -> Person -> Object
```javascript
let person2 = Object.create(person1);
```
create() 实际做的是从指定原型对象创建一个新的对象。这里以 person1 为原型对象创建了 person2 对象。在控制台输入：
```javascript
person2.__proto__
```
结果返回对象person1。










## 野路子
```javascript
const factory = (age, gender) => {
    return {
        age: age,
        gender: gender
    }
}
console.log(factory(10, 'male'));
// age: 10
// gender: "male"
// __proto__:
//     constructor: ƒ Object()
//     hasOwnProperty: ƒ hasOwnProperty()
//     isPrototypeOf: ƒ isPrototypeOf()
//     propertyIsEnumerable: ƒ propertyIsEnumerable()
//     toLocaleString: ƒ toLocaleString()
//     toString: ƒ toString()
//     valueOf: ƒ valueOf()
//     __defineGetter__: ƒ __defineGetter__()
//     __defineSetter__: ƒ __defineSetter__()
//     __lookupGetter__: ƒ __lookupGetter__()
//     __lookupSetter__: ƒ __lookupSetter__()
//     get __proto__: ƒ __proto__()
//     set __proto__: ƒ __proto__()
```

## NEW
```javascript
function Person(firstName) {
  this.firstName = firstName;
}

Person.prototype.sayHello = function() {
  alert("Hello, I'm " + this.firstName);
};

var person1 = new Person("Alice");
var person2 = new Person("Bob");

// call the Person sayHello method.
person1.sayHello(); // alerts "Hello, I'm Alice"
person2.sayHello(); // alerts "Hello, I'm Bob"

console.log(person1);
Person {firstName: "Alice"}
```

Person {firstName: "Alice"}

- firstName: "Alice"
- `__proto__`:
    - sayHello: ƒ ()
    - constructor: ƒ Person(firstName)
    - `__proto__`: Object













# 继承
https://zhuanlan.zhihu.com/p/37735247

## 原型链继承
父类的实例作为子类的原型。
```javascript
function People(age) {
    this.age = age || 50;
}

function Woman(){ 

}
Woman.prototype= new People();
Woman.prototype.name = 'haixia';
let womanObj = new Woman();
console.log(womanObj);
```
- 优点
    1. 父类新增的属性name，子类能访问
- 缺点
    1. 无法实现多继承
    2. 创建子类实例时，不能向父类构造函数中传参
    3. 啥意思？如果要新增加原型属性和方法需要在new 父类构造函数的后面

## 借用构造函数继承（伪造对象、经典继承）
复制父类的实例属性给子类。
```javascript
function Woman(name){
 //继承了People
  People.call(this); //People.call(this，'wangxiaoxia'); 
  this.name = name || 'renbo'
}
let womanObj = new Woman();
console.log(womanObj);
```

- 优点
    1. 这样就可以多继承了

Woman {age: 50, name: "renbo"}
- age: 50
- name: "renbo"
- `__proto__`: Object

```javascript
function People(name,age){
  this.name = name || 'wangxiao'
  this.age = age || 27
}
People.prototype.eat = function(){
  return this.name + this.age + 'eat sleep'
}

function Woman(name,age){
  People.call(this,name,age)
}
Woman.prototype = new People();
Woman.prototype.constructor = Woman;
let wonmanObj = new Woman(ren,27);
wonmanObj.eat(); 
```

### 寄生组合继承
通过寄生的方式来修复组合式继承的不足，完美的实现继承
```javascript
//父类
function People(name,age){
  this.name = name || 'wangxiao'
  this.age = age || 27
}
//父类方法
People.prototype.eat = function(){
  return this.name + this.age + 'eat sleep'
}
//子类
function Woman(name,age){
  //继承父类属性
  People.call(this,name,age)
}
//继承父类方法
(function(){
  // 创建空类
  let Super = function(){};
  Super.prototype = People.prototype;
  //父类的实例作为子类的原型
  Woman.prototype = new Super();
})();
//修复构造函数指向问题
Woman.prototype.constructor = Woman;
let womanObj = new Woman();
console.log(womanObj);
```

### ES6
```javascript
//class 相当于es5中构造函数
//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中
//class中定义的所有方法是不可枚举的
//class中只能定义方法，不能定义对象，变量等
//class和方法内默认都是严格模式
//es5中constructor为隐式属性
class People{
  constructor(name='wang',age='27'){
    this.name = name;
    this.age = age;
  }
  eat(){
    console.log(`${this.name} ${this.age} eat food`)
  }
}
//继承父类
class Woman extends People{ 
   constructor(name = 'ren',age = '27'){ 
     //继承父类属性
     super(name, age); 
   } 
    eat(){ 
     //继承父类方法
      super.eat() 
    } 
} 
let wonmanObj=new Woman('xiaoxiami'); 
wonmanObj.eat();
```
