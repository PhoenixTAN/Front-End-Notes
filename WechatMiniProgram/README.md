# 微信小程序

https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/

## 小程序与普通网页开发的区别

小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。

​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。

## 双线程模型
https://juejin.cn/post/6930897871529213966

从运行机制的角度上来说，JavaScript 设计成单线程主要是避免多线程操作 DOM 造成 UI 冲突，如果多个线程操作同一个 DOM，浏览器很难判断最终的 UI 效果采用哪个线程的结果，虽然可以采用类似于 java 的锁机制来处理，但是这样一来就大大加大了 JavaScript 的复杂性。这也解释了为啥 GUI 渲染线程和 JavaScript 引擎是互斥的，JavaScript 有修改 DOM 的权限，不互斥就很容易打架，造成页面卡死。

从设计的角度上来说，当初设计 JavaScript 语言的时候定位的就是一门 “简单” 的语言，没有丰富的语言特性，也没有大一统的野心，更没有“包打天下”的虚拟机引擎，是真正的 “小而简洁”，从这个角度上来说，JavaScript 也不可能设计出多线程来，毕竟光多线程编程，都可以作为一门课程来讲。

当 JavaScript 代码被执行时，GUI 渲染线程会被挂起，等待 JavaScript 引擎线程空闲时再被执行，以免在渲染期间被 JavaScript 重复地修改 DOM 造成不必要的渲染压力。采用互斥的模式等待 JavaScript 代码执行完毕之后，可以保证页面渲染的是最终的执行结果。所以浏览器的空间时间（ldle）也成了衡量网站性能的指标之一，空闲时长多代表 JavaScript 逻辑不密集以及 DOM 改动频率低，浏览器可以更快速顺畅地响应用户的交互。

**为啥小程序不用浏览器的线程模型**：
从上文来看，其实小程序也是可以使用类似的 Worker 线程来跑业务逻辑，用 webView 来渲染页面，从理论上来说这样是没问题，但是从小程序的以下几点来分析，却是有问题的。

从平台的角度来看，平台最核心的考量点是对外提供能力的前提下，保证自身平台的足够安全。比如涂鸦 IoT 平台，对外给开发者提供控制设备的能力，但是必须保证自己本身平台和数据足够安全。对于微信来说也是如此，小程序在微信这个宿主上跑，但是不能有全部的 web 能力的，不然如果被执行一些危险的、会超出微信控制的代码（比如 eval）。

从性能的角度上来看，浏览器的主线程与 Worker 之间的通信内容，可以是文本、也可以是对象。但是这种通信是传值而不是传地址，不管你传的基本数据类型还是引用数据类型，一律传值。这样的好处是 Worker 对通信内容的修改，不会影响主线程，坏处是影响效率，如果我要发一个 100MB ，主线程需要对原文件做一个拷贝，把值通过 postMessage 的方式给到 Worker 线程，整体传输的效率就会大大降低。而如果设计一个双线程模型，这两个线程是并列的,两个都是独立的主线程，传值让 Native 来做,而且因为渲染进程的角色是单一的,就是只负责渲染,不会有逻辑的代码,整体的架构和性能也将会更加清晰.
从开发的角度来看, Worker 线程里是无法获取 dom 节点的，但是在有些开发情境下，还是需要获取 Dom 节点，并做一些操作，所以 Worker 无法胜任，而在小程序的逻辑进程中，虽然腾讯是尽量不让我们去获取节点，但是还是有接口去异步的获取节点信息，完成一些特殊的操作。

从以上这几个角度上来看，小程序的双线程模型已经大致清晰了。小程序的双线程指的是渲染线程和逻辑线程，这两个线程分别承担 UI 渲染和执行 JavaScript 代码的工作。如下图所示

![](./images/two-threads-model.png) 

小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。

小程序的双线程通信是不是在渲染线程和逻辑线程之间直接传递数据或事件，而是用 Native 来作为媒介来进行转发，整个过程是比较典型的事件驱动模式：

- 渲染层通过与用户的交互触发特定的事件 event；
- event 通过 Native 传递给逻辑层
- 逻辑层收到触发某个事件,并通过一系列的逻辑处理、数据请求、接口调用等工作将加工好的数据通过 setData 的方法传递给渲染层
- 渲染层将 data 渲染为可视化的 UI

## 小程序代码构成
### 小程序配置 app.json
app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 app.json 配置内容如下：

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  }
}
```

我们简单说一下这个配置各个项的含义:

1. `pages`字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
2. `window`字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。


### WXML 模板
从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。

同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。打开 `pages/index/index.wxml`，你会看到以下的内容:
```html
<view class="container">
  <view class="userinfo">
    <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>
    <block wx:else>
      <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>
      <text class="userinfo-nickname">{{userInfo.nickName}}</text>
    </block>
  </view>
  <view class="usermotto">
    <text class="user-motto">{{motto}}</text>
  </view>
</view>
```
和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：

1. 标签名字有点不一样

    往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。

    从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。


2. 多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式

    在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。

    小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。

    WXML 是这么写 :
```html
<text>{{msg}}</text>
```
JS 只需要管理状态即可:
```html
this.setData({ msg: "Hello World" })
```
通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。



### WXSS 样式
WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。

1. 新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 `rpx` ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。

2. 提供了全局的样式和局部样式。和前边 `app.json`, `page.json` 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。

3. 此外 WXSS 仅支持部分 CSS 选择器


### JS 逻辑交互
一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。
```html
<view>{{ msg }}</view>
<button bindtap="clickMe">点击我</button>
```
点击 `button` 按钮的时候，我们希望把界面上 `msg` 显示成 `"Hello World"`，于是我们在 `button` 上声明一个属性: `bindtap` ，在 JS 文件里边声明了 `clickMe` 方法来响应这次点击操作：
```js
Page({
  clickMe: function() {
    this.setData({ msg: "Hello World" })
  }
})
```
响应用户的操作就是这么简单。

此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 `pages/index/index.js` 就调用了 `wx.getUserInfo` 获取微信用户的头像和昵称，最后通过 `setData` 把获取到的信息显示到界面上。


## 程序与页面
微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。

紧接着通过 `app.json` 的 pages 字段就可以知道你当前小程序的所有页面路径:
```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```
这个配置说明在 QuickStart 项目定义了两个页面，分别位于 `pages/index/index` 和 `pages/logs/logs`。而写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。

于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。

小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:
```js
App({
  onLaunch: function () {
    // 小程序启动之后 触发
  }
})
```
**整个小程序只有一个 App 实例，是全部页面共享的。**

接下来我们简单看看小程序的一个页面是怎么写的。

你可以观察到 `pages/logs/logs` 下其实是包括了4种文件的，微信客户端会先根据 `logs.json` 配置生成一个界面，顶部的颜色和文字你都可以在这个 `json` 文件里边定义好。紧接着客户端就会装载这个页面的 `WXML` 结构和 `WXSS` 样式。最后客户端会装载 `logs.js`，你可以看到 `logs.js` 的大体内容就是:
```js
Page({
  data: { // 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    // 页面渲染后 执行
  }
})
```
`Page` 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 `data` 数据和 `index.wxml` 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。

在渲染完界面之后，页面实例就会收到一个 `onLoad` 的回调，你可以在这个回调处理你的逻辑。

有关于 `Page` 构造器更多详细的文档参考 注册页面 `Page` 。

### 组件
小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。

就像 HTML 的 div, p 等标签一样，在小程序里边，你只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：
```html
<map></map>
```
使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:
```html
<map longitude="广州经度" latitude="广州纬度"></map>
```
组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：
```html
<map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>
```
当然你也可以通过 style 或者 class 来控制组件的外层样式，以便适应你的界面宽度高度等等。


### API
为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。

要获取用户的地理位置时，只需要：
```js
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude // 纬度
    var longitude = res.longitude // 经度
  }
})
```
调用微信扫一扫能力，只需要：
```js
wx.scanCode({
  success: (res) => {
    console.log(res)
  }
})
```
需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。





