# 微信小程序

https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/

## 小程序与普通网页开发的区别

小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。

​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。

## 双线程模型
https://juejin.cn/post/6930897871529213966

从运行机制的角度上来说，JavaScript 设计成单线程主要是避免多线程操作 DOM 造成 UI 冲突，如果多个线程操作同一个 DOM，浏览器很难判断最终的 UI 效果采用哪个线程的结果，虽然可以采用类似于 java 的锁机制来处理，但是这样一来就大大加大了 JavaScript 的复杂性。这也解释了为啥 GUI 渲染线程和 JavaScript 引擎是互斥的，JavaScript 有修改 DOM 的权限，不互斥就很容易打架，造成页面卡死。

从设计的角度上来说，当初设计 JavaScript 语言的时候定位的就是一门 “简单” 的语言，没有丰富的语言特性，也没有大一统的野心，更没有“包打天下”的虚拟机引擎，是真正的 “小而简洁”，从这个角度上来说，JavaScript 也不可能设计出多线程来，毕竟光多线程编程，都可以作为一门课程来讲。

当 JavaScript 代码被执行时，GUI 渲染线程会被挂起，等待 JavaScript 引擎线程空闲时再被执行，以免在渲染期间被 JavaScript 重复地修改 DOM 造成不必要的渲染压力。采用互斥的模式等待 JavaScript 代码执行完毕之后，可以保证页面渲染的是最终的执行结果。所以浏览器的空间时间（ldle）也成了衡量网站性能的指标之一，空闲时长多代表 JavaScript 逻辑不密集以及 DOM 改动频率低，浏览器可以更快速顺畅地响应用户的交互。

**为啥小程序不用浏览器的线程模型**：
从上文来看，其实小程序也是可以使用类似的 Worker 线程来跑业务逻辑，用 webView 来渲染页面，从理论上来说这样是没问题，但是从小程序的以下几点来分析，却是有问题的。

从平台的角度来看，平台最核心的考量点是对外提供能力的前提下，保证自身平台的足够安全。比如涂鸦 IoT 平台，对外给开发者提供控制设备的能力，但是必须保证自己本身平台和数据足够安全。对于微信来说也是如此，小程序在微信这个宿主上跑，但是不能有全部的 web 能力的，不然如果被执行一些危险的、会超出微信控制的代码（比如 eval）。

从性能的角度上来看，浏览器的主线程与 Worker 之间的通信内容，可以是文本、也可以是对象。但是这种通信是传值而不是传地址，不管你传的基本数据类型还是引用数据类型，一律传值。这样的好处是 Worker 对通信内容的修改，不会影响主线程，坏处是影响效率，如果我要发一个 100MB ，主线程需要对原文件做一个拷贝，把值通过 postMessage 的方式给到 Worker 线程，整体传输的效率就会大大降低。而如果设计一个双线程模型，这两个线程是并列的,两个都是独立的主线程，传值让 Native 来做,而且因为渲染进程的角色是单一的,就是只负责渲染,不会有逻辑的代码,整体的架构和性能也将会更加清晰.
从开发的角度来看, Worker 线程里是无法获取 dom 节点的，但是在有些开发情境下，还是需要获取 Dom 节点，并做一些操作，所以 Worker 无法胜任，而在小程序的逻辑进程中，虽然腾讯是尽量不让我们去获取节点，但是还是有接口去异步的获取节点信息，完成一些特殊的操作。

从以上这几个角度上来看，小程序的双线程模型已经大致清晰了。小程序的双线程指的是渲染线程和逻辑线程，这两个线程分别承担 UI 渲染和执行 JavaScript 代码的工作。如下图所示

![](./images/two-threads-model.png) 

小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。

小程序的双线程通信是不是在渲染线程和逻辑线程之间直接传递数据或事件，而是用 Native 来作为媒介来进行转发，整个过程是比较典型的事件驱动模式：

- 渲染层通过与用户的交互触发特定的事件 event；
- event 通过 Native 传递给逻辑层
- 逻辑层收到触发某个事件,并通过一系列的逻辑处理、数据请求、接口调用等工作将加工好的数据通过 setData 的方法传递给渲染层
- 渲染层将 data 渲染为可视化的 UI
