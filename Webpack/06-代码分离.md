# 代码分离

代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。

常用的代码分离方法有三种：
- 入口起点：使用 entry 配置手动地分离代码。
- 防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。
- 动态导入：通过模块的内联函数调用来分离代码。
- 预获取/预加载模块(prefetch/preload module)


## 入口起点(entry point)
```
webpack-demo
|- package.json
|- package-lock.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
  |- another-module.js
|- /node_modules
```

**another-module.js**
```js
import _ from 'lodash';

console.log(_.join(['Another', 'module', 'loaded!'], ' '));
```

**webpack.config.js**
```
 entry: {
    index: "./src/index.js",
    print: "./src/print.js",
  },
  output: {
    filename: "[name].bundle.js",
    path: path.resolve(__dirname, "dist"),
    clean: true
  },
```

正如前面提到的，这种方式存在一些隐患：

- 如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。
- 这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。

以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 ./src/index.js 中也引入过 lodash，这样就在两个 bundle 中造成重复引用。在下一章节会移除重复的模块。

## 防止重复(prevent duplication)
### 入口依赖
配置 dependOn option 选项，这样可以在多个 chunk 之间共享模块
```js
const path = require('path');

module.exports = {
   mode: 'development',
   entry: {
    index: './src/index.js',
    another: './src/another-module.js',
    index: {
      import: './src/index.js',
      dependOn: 'shared',
    },
    another: {
      import: './src/another-module.js',
      dependOn: 'shared',
    },
    shared: 'lodash',
   },
   output: {
     filename: '[name].bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
};
```

### SplitChunksPlugin
SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 lodash 模块去除：

webpack.config.js
```js
const path = require('path');

module.exports = {
    mode: 'development',
    entry: {
      index: './src/index.js',
      another: './src/another-module.js',
    },
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
   optimization: {
     splitChunks: {
       chunks: 'all',   // here
     },
   },
};
```

```
...
[webpack-cli] Compilation finished
asset vendors-node_modules_lodash_lodash_js.bundle.js 549 KiB [compared for emit] (id hint: vendors)
asset index.bundle.js 8.92 KiB [compared for emit] (name: index)
asset another.bundle.js 8.8 KiB [compared for emit] (name: another)
Entrypoint index 558 KiB = vendors-node_modules_lodash_lodash_js.bundle.js 549 KiB index.bundle.js 8.92 KiB
Entrypoint another 558 KiB = vendors-node_modules_lodash_lodash_js.bundle.js 549 KiB another.bundle.js 8.8 KiB
runtime modules 7.64 KiB 14 modules
cacheable modules 530 KiB
  ./src/index.js 257 bytes [built] [code generated]
  ./src/another-module.js 84 bytes [built] [code generated]
  ./node_modules/lodash/lodash.js 530 KiB [built] [code generated]
webpack 5.4.0 compiled successfully in 241 ms
```

## 动态导入(dynamic import)
使用符合 ECMAScript 提案 的 `import()` 语法 来实现动态导入。

```js
async function getComponent() {
  const element = document.createElement("div");
  const { default: _ } = await import(/* webpackChunkName: "lodash" */ "lodash");   // 这里给动态导入的包起个别名

  element.innerHTML = _.join(["Hello", "webpack"], " ");
  return element;
}

getComponent().then((component) => {
   document.body.appendChild(component);
});

```

```js
  output: {
    filename: "[name].bundle.js",
    chunkFilename: "[name].bundle.js",  // 给动态导入的包起个名字
    path: path.resolve(__dirname, "dist"),
    clean: true,
  }
```

```
PS D:\WebpackPlayground> npm run build

> WebpackPlayground@1.0.0 build D:\WebpackPlayground
> webpack --mode production

asset lodash.bundle.js 68.9 KiB [emitted] [minimized] (name: lodash) (id hint: vendors) 1 related asset
asset index.bundle.js 3.25 KiB [emitted] [minimized] (name: index)
asset index.html 223 bytes [compared for emit]
runtime modules 7.95 KiB 11 modules
cacheable modules 532 KiB
  ./src/index.js 335 bytes [built] [code generated]
  ./node_modules/lodash/lodash.js 531 KiB [built] [code generated]
webpack 5.75.0 compiled successfully in 2346 ms
```
你就能看见单独打出来的lodash包。

## prefetch/preload module

在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：

- prefetch(预获取)：将来某些导航下可能需要的资源
- preload(预加载)：当前导航下可能需要资源

### prefetch
下面这个 prefetch 的简单示例中，有一个 HomePage 组件，其内部渲染一个 LoginButton 组件，然后在点击后按需加载 LoginModal 组件。

LoginButton.js
```js
//...
import(/* webpackPrefetch: true */ './path/to/LoginModal.js');
```
这会生成 `<link rel="prefetch" href="login-modal-chunk.js">` 并追加到页面头部，指示着浏览器在闲置时间预取 `login-modal-chunk.js` 文件。

只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。

### preload
- preload chunk 会在父 chunk 加载时，以并行方式开始加载。 
- prefetch chunk 会在父 chunk 加载结束后开始加载。
- preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
- preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。
- 浏览器支持程度不同。

我们假想这里的图表组件 ChartComponent 组件需要依赖一个体积巨大的 ChartingLibrary 库。它会在渲染时显示一个 LoadingIndicator(加载进度条) 组件，然后立即按需导入 ChartingLibrary：

**ChartComponent.js**
```js
//...
import(/* webpackPreload: true */ 'ChartingLibrary');
```

## bundle分析
`webpack-bundle-analyzer` 扫描 bundle 并构建其内部内容的可视化。使用此可视化来查找大的或不必要的依赖项。



