# Webpack性能优化专题

## 代码分离
对于 HTTP/1.1 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 HTTP/2 来说，你还可以使用**代码分割**进行进一步优化。 https://webpack.js.org/guides/code-splitting/


### SplitChunksPlugin
SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 lodash 模块去除：

webpack.config.js
```js
const path = require('path');

module.exports = {
    mode: 'development',
    entry: {
      index: './src/index.js',
      another: './src/another-module.js',
    },
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
   optimization: {
     splitChunks: {
       chunks: 'all',   // here
     },
   },
};
```


### 动态导入(dynamic import)
使用符合 ECMAScript 提案 的 `import()` 语法 来实现动态导入。


```js
async function getComponent() {
  const element = document.createElement("div");
  const { default: _ } = await import(/* webpackChunkName: "lodash" */ "lodash");   // 这里给动态导入的包起个别名

  element.innerHTML = _.join(["Hello", "webpack"], " ");
  return element;
}

getComponent().then((component) => {
   document.body.appendChild(component);
});

```

```js
  output: {
    filename: "[name].bundle.js",
    chunkFilename: "[name].bundle.js",  // 给动态导入的包起个名字
    path: path.resolve(__dirname, "dist"),
    clean: true,
  }
```

```
PS D:\WebpackPlayground> npm run build

> WebpackPlayground@1.0.0 build D:\WebpackPlayground
> webpack --mode production

asset lodash.bundle.js 68.9 KiB [emitted] [minimized] (name: lodash) (id hint: vendors) 1 related asset
asset index.bundle.js 3.25 KiB [emitted] [minimized] (name: index)
asset index.html 223 bytes [compared for emit]
runtime modules 7.95 KiB 11 modules
cacheable modules 532 KiB
  ./src/index.js 335 bytes [built] [code generated]
  ./node_modules/lodash/lodash.js 531 KiB [built] [code generated]
webpack 5.75.0 compiled successfully in 2346 ms
```
你就能看见单独打出来的lodash包。

### 用插件将 CSS 从主应用程序中分离


### 预获取/预加载模块 prefetch/preload module

在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：

- prefetch(预获取)：将来某些导航下可能需要的资源
- preload(预加载)：当前导航下可能需要资源

#### prefetch
下面这个 prefetch 的简单示例中，有一个 HomePage 组件，其内部渲染一个 LoginButton 组件，然后在点击后按需加载 LoginModal 组件。

LoginButton.js
```js
//...
import(/* webpackPrefetch: true */ './path/to/LoginModal.js');
```
这会生成 `<link rel="prefetch" href="login-modal-chunk.js">` 并追加到页面头部，指示着浏览器在闲置时间预取 `login-modal-chunk.js` 文件。

只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。

#### preload
- preload chunk 会在父 chunk 加载时，以并行方式开始加载。 
- prefetch chunk 会在父 chunk 加载结束后开始加载。
- preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。
- preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。
- 浏览器支持程度不同。

我们假想这里的图表组件 ChartComponent 组件需要依赖一个体积巨大的 ChartingLibrary 库。它会在渲染时显示一个 LoadingIndicator(加载进度条) 组件，然后立即按需导入 ChartingLibrary：

**ChartComponent.js**
```js
//...
import(/* webpackPreload: true */ 'ChartingLibrary');
```

## bundle分析
`webpack-bundle-analyzer` 扫描 bundle 并构建其内部内容的可视化。使用此可视化来查找大的或不必要的依赖项。


## 压缩CSS

- 注意，在多数情况下，你也可以进行 压缩 CSS，以便在生产环境中节省加载时间。最重要的是，现有的 loader 可以支持任何你可以想到的 CSS 风格 - postcss, sass 和 less 等。为了压缩输出文件，请使用类似于 `css-minimizer-webpack-plugin` 这样的插件。https://www.webpackjs.com/plugins/mini-css-extract-plugin/#minimizing-for-production



## 缓存
### content hash code
```
filename: '[name].[contenthash].js',   // here
```

### vendor chunk

将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。 这可以通过使用 SplitChunksPlugin 示例 2 中演示的 SplitChunksPlugin 插件的 cacheGroups 选项来实现。我们在 optimization.splitChunks 添加如下 cacheGroups 参数并构建：
```
optimization: {
    runtimeChunk: 'single',
    splitChunks: {
       cacheGroups: {
         vendor: {
           test: /[\\/]node_modules[\\/]/,
           name: 'vendors',
           chunks: 'all',
         },
       },
    },
},
```